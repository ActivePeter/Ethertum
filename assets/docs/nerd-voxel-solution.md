

# Nerd 体素方案

## 目标

1. 远景渲染
    - 原始地形 LoD
    - 可选 远处修改过的地形LoD (比如远处城堡 或原处挖空了一座山)
    - 可选 远处地平线往下拉成半球 (仅视觉上)
    - ?基于 3dgs 的 LoD?
2. 近处精确修改
3. 小的存档体积
4. 不影响游戏性 仍可如mc红石那样的游戏性和灵活自由度

### 额外功能

- 避免重复生成空区域 在(生成后/挖空后)标记空的地方


# 具体方案

先生成流形层  
??然后根据 raymatch 在样条线上插值出体素 (八叉树可以加速体素生成的过程)




## 世界结构

### Chunk & Voxel
> 每个 Chunk 的尺寸相等且很大 e.g. 256^3  
Chunk 里是稀疏Octree, 存修改后的体素  
每个体素的大小都是1.0 (还是不定? 可以是[1.0, 0.5, 0.25, 0.125...])

### Logic Distance

> *逻辑距离*内的区块 是真实加载/逻辑更新的区块 (植物会生长 动物会动 红石会运行)  
RAM里会存所有这些体素 以便逻辑更新，但只有玩家更改的体素才会被持久化存盘。  
相反,  
在逻辑距离以外的远景，就是假的多级LoD - 只有粗略视觉 没有逻辑更新，而且不确保视觉的准确性

逻辑距离以外的远景，可以相对随意些 就是个视觉效果。  
但逻辑距离内，就要严谨，因为涉及到真实的游戏逻辑。

在逻辑范围内

### Layers

世界有多个层：  
分为 流形层(地形层 植被层 遗迹/村庄层)，用户修改层

## 程序过程

玩家进入世界后 设玩家位置为 player.pos: Vec3, (真实加载/更新)逻辑距离为 player.logic_distance: u32 (半径 单位: 区块数量)

视距内的地形 都是

# 附录

## 词汇表

- 流形层 (Raymatch-able / SDF / Spline样条):   
    原始地形, 类似于传统的不可变世界  
    可用于生成LoD Mesh, 体素。总是一致的(相同世界相同位置)

- [3dgs](https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/
): 

## 原始会话

<details>


Nerd: 

我目前的想法是生成过的地方永远占有一个体素

标记为生成过的空

这个地方被挖走了也不是没有, 而是这个特殊的体素

这样就不会重复生成

但是这种生成方式仅仅适用于流形层不变的情况下

如果我们想要再模拟地形演化或者其他的会改变流形层的情况就会出现不一致

但是会变会很酷
火山爆发, 造山运动


,

dre: 或许可以 粗略读档 然后生成存档lod缓存

nerd: 
那样的话不如用 3dgs
只是做 lod 的话
3dgs 稳定, 质量更好

这也是我推荐样条形的原因, 我们实际上没有直接渲染流形层的需求, lod 要想实际表现肯定应该用别的方案

除非就直接上混合渲染, 同时直接 sdf 和修改后的体素, 然后用 z-buffer 剔除

感觉这个方案也不错, 不过要注意体素贴图部分的采样

，

如果能实现这个, 再在 shader 上做点手脚就直接无限远的视距

比如把生成距离尽头藏在地平线下面, 让人有一直在星球上的错觉

太酷啦

配合纵向区块划分我们说不定能做实际世界的地形尺度

虽然感觉会不好玩

毕竟一个山区跑几天才有可能出去

arma3 真切的演示了这种地形的游戏体验

没载具带你就是寄

，

dre: 挖空山的话，能不能读取挖空山的体素（假设是空气 因为全被挖空了）然后转换成sdf 运用到‘流行层’(原始地形) 的sdf上

nerd: 不是

sdf 就是你想的流形层的存储方案

我只是指出 sdf 可能没那么合适, 所以起了个这个名字

挖空山其实有简单的解决办法

多存点体素, 把 "挖空的体素" 和周围的体素都存上

然后继续用 z-buffer 剔除就解决了

卧槽, 这么简单

完事

完美的方案

至少在口头上完美

saurlax: 意思是相当于两个图层，原始生成的内容在底下，玩家的修改在上层。如果有玩家的修改就会直接覆盖掉原始生成的地形吗

dre: 好像是欸，就是修改过的地方 单独生成一层LoD 覆盖在流行层LoD之上 是嘛
 
nerd: 一个空体素和它周围的 8 个体素都要实际存上

嗯嗯

完美的方案

可以修改, 无限视距, 快速生成

，

超大区块

然后稀疏

不遍历

我们不生成完整的体素

是 Chunk 很大, 里面是八叉树

我们这个方案的目的不就是干掉遍历吗?

现在不用一个区块一个区块生成了

除了 gameplay 还有啥需要遍历

而且一个问题

你如何遍历没有生成的体素呢, 我们这个方案持久化的体素极少

suar: 不过树这些点缀物也可以sdf吗，会不会在美工方面更困难

或者比如我想做一个城市/村庄的生成器呢

nerd: 直接存体素不就行了

你这种东西开销又不大, 直接在下层存好就行了

分层生成就是为了处理这个层擅长的结构

saur: 那实际加载区块的时间会不会更长，玩家一直处在一种类似跑图的状态

甚至进入热点区域比野外还要慢

nerd: 还是一样的解释

你生成这种东西肯定是在下层做

和流形层关系不大

下层 是指用户修改层嘛（我们一共就2层是吗

(前者)对

还有就是流形层也不一定只是 sdf

只要是可以接受 ray match 的几何结构都没问题

只是个设计上的抽象

saur: 相当于有data的内容就直接丢给用户层来运行了

流形层类似于传统游戏中不可变的地形

nerd:

你可以有很多层啊

通过 raymatch 得到下层的体素啊

不然体素从哪里来

我知道, 我是说 sdf 之类的可以实现 Raymatch 这个 trait 的不就都可以

可以有很多层, 比如地形是一层, 树是一层, 很远的地方的村庄道路田地是没有意义的, 然后村庄啥的再是一层

不是生成了就要存下, 修改了才存


只要保证一致性就行了

而且在 lod 范围内 才会生成 所以其实没多少

完整表述一遍吧

,

流形层是其他方便生成和存储地形且支持 raymatch 的几何结构构成, 用于生成一致的 lod 和体素

当流形层结构进入玩家视野会判断 lod 层级

然后根据层级生成对应的 lod 结构

最小的 lod 范围的结构是体素

这个范围包含玩家所有对结构可以进行的修改

在这个范围内的修改会被持久化, 包括移除

流形层可以不止一层, 用来负责不同的结构生成, 根据 lod 的层级不同一部分流形层的内容可以被忽略, 也就没有必要生成

</details>